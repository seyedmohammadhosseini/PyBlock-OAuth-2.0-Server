# This Class implements a common interface to many different secure hash and message digest algorithms.
# Included are the secure hash algorithms SHA1, SHA224, SHA256, SHA384, and SHA512
# as well as RSAâ€™s MD5 algorithm
# https://pypi.org/project/rsa/

import hashlib, binascii, os
from Cryptodome.Signature import pkcs1_15
from Cryptodome.Hash import SHA256
from Cryptodome.PublicKey import RSA
import base64
import json


class controller:

    # Initialize the Secure class
    # :param register: access to all other class
    def __init__(self, register):
        self.register = register

    # Hash a password for storing in database
    # :param password: a string of password
    @staticmethod
    def hash_password(password):
        salt = hashlib.sha256(os.urandom(60)).hexdigest().encode('ascii')
        pwdhash = hashlib.pbkdf2_hmac('sha512', password.encode('utf-8'), salt, 100000)
        pwdhash = binascii.hexlify(pwdhash)
        return (salt + pwdhash).decode('ascii')

    # Verify a stored password against one provided by user
    # :param stored_password: stored password
    # :param provided_password: a string of password
    @staticmethod
    def verify_password(stored_password, provided_password):
        salt = stored_password[:64]
        stored_password = stored_password[64:]
        pwdhash = hashlib.pbkdf2_hmac('sha512',
                                      provided_password.encode('utf-8'),
                                      salt.encode('ascii'),
                                      100000)
        pwdhash = binascii.hexlify(pwdhash).decode('ascii')
        return pwdhash == stored_password

    # Token Generator by binascii module
    # The binascii module contains a number of methods to convert between binary and various ASCII-encoded binary
    # representations.
    # :param length: length of token
    # :return : token string
    @staticmethod
    def generate_token(length):
        return binascii.hexlify(os.urandom(length)).decode()

    # public key to "encrypt" (or "decrypt" which is same in "textbook" RSA) the signature and get
    # hashed message. If the hashed message equals hashed message, then you verified the message being correctly signed.
    # :param public_key: public key - Generated by RSA
    # :param message: message to check
    # :param signature: RSA signature
    # :return: True if equal, else False
    @staticmethod
    def signature_verify(public_key, message, signature):
        try:
            if isinstance(message, dict):
                message = json.dumps(message)
                message = message.replace('": ', '":')
                message = message.replace(", ", ",")
                message = bytes(message.encode())
            signature += "=" * ((4 - len(signature) % 4) % 4)
            signature = base64.b64decode(signature).hex()
            signature = bytes.fromhex(signature)
            message_hash = SHA256.new(message)
            pubkey = RSA.import_key(public_key)
            pkcs1_15.new(pubkey).verify(message_hash, signature)
            print("The signature is valid.")
            return True
        except (ValueError, TypeError):
            print("The signature is not valid.")
            return False
